---
title: Prednáška 23
---

* TOC
{:toc}

## Nepreberané črty jazykov C a C++

Dnešná prednáška bude venovaná (pomerne plytkému) prehľadu rôznych čŕt
jazykov C a C++, ktoré sa počas semestra nepreberali. Tento prehľad by
mal poslúžiť ako pomôcka pri štúdiu existujúcich programov, resp. ako
inšpirácia pre ďalšie samoštúdium.

Znalosť materiálu z tejto prednášky *nebude* vyžadovaná na skúške.
Rovnako *nie je* odporúčané na skúške tento materiál využívať bez
dôkladného samostatného oboznámenia sa s ním.

Táto prednáška nepokrýva objektovo-orientované programovanie v jazyku
C++. Objektovo-orientované programovanie (v jazyku Java) bude hlavnou
náplňou druhého semestra programovania.

## Rozdiely medzi jazykmi C a C++

Jazyk C vznikol okolo roku 1972 na podporu vývoja operačného systému
Unix; jazyk C++ okolo roku 1985. Programy v jazyku C sú väčšinou súčasne
aj korektnými programami v jazyku C++ (ide ale o isté zjednodušenie).
Obidva tieto jazyky existujú vo viacerých štandardoch, v ktorých sa
postupne pridávali nové črty.

V priebehu semestra sme programovali v jazyku C++. Veľká časť
konštrukcií, ktoré sme v programoch využívali, však pochádza už z
jazyka C. Výnimkami sú však napríklad nasledujúce črty jazyka C++, ktoré
v jazyku C nie sú k dispozícii:

  - V jazyku C nie je možné predávanie parametrov funkcií referenciou.
    Namiesto toho je potrebné používať smerníky.
  - V jazyku C nefungujú operátory `new` a `delete`. Namiesto nich treba
    použiť funkcie popísané nižšie.
  - Na používanie typu `bool` a konštánt `true` a `false` je potrebná
    knižnica `stdbool` (t. j. `#include <stdbool.h>`). Zabudovaný
    booleovský typ má názov `_Bool` a nadobúda hodnoty `0` a `1`.
  - Štandardnými knižnicami jazyka C sú spomedzi štandardných knižníc
    jazyka C++ v zásade tie začínajúce písmenom `c`, napríklad `cstdio`.
    Namiesto ` #include  `<cstdio> potom v C píšeme `#include
    <stdio.h>`.
      - V jazyku C špeciálne nie je možné používať knižnicu `iostream` a
        v nej definované štandardné vstupno-výstupné prúdy `cin` a
        `cout`.
  - Ak máme napr. `struct bod`, v C++ sme premenné deklarovali cez `bod
    b;`, v jazyku C treba písať `struct bod b;`.
  - V starších verziách jazyka C nefungujú mnohé konštrukcie jazyka C++,
    ktoré sme bežne používali, napríklad komentáre vo forme `//`,
    deklarácie premenných inde ako na začiatku funkcie, atď.

## Nepreberané črty jazyka C (použiteľné aj v C++)

### Enumerované typy

Enumerované typy pozostávajú z vymenovania niekoľkých hodnôt, ktoré sa
stanú celočíselnými konštantami. To je občas užitočné na sprehľadnenie
zdrojového kódu.

*Príklad*:

```cpp
#include <iostream>
using namespace std;

int main() {
    // definicia enumerovaneho typu farba
    enum farba {biela, modra, cervena, zelena, cierna};  
    // definicia premennej typu farba     
    farba f = biela;                                     
    f = zelena; 
    cout << f << endl; // vypise 3
}
```

### Zložený typ (`union`)

Zložený typ umožňuje na jednom mieste pamäte uchovávať hodnotu, ktorá
môže byť viacerých dátových typov (na rozdiel od štruktúr však vždy
ide o práve jednu hodnotu). Definuje sa podobne ako štruktúra, avšak s
použitím kľúčového slova `union` namiesto `struct`.

*Príklad*:

```cpp
#include <iostream>
#include <cstring>
using namespace std;

union zlozenyTyp {
    int n;
    char s[8];
};

int main() {
    zlozenyTyp z;
    z.n = 10;
    cout << z.n << endl;  // vypise 10
    strcpy(z.s, "abcd");
    cout << z.s << endl;  // vypise abcd
    cout << z.n << endl;  // vypise nejaky nezmysel
}
```

Napríklad pri aritmetických stromoch by použitie zloženého typu umožnilo
ušetriť trochu pamäte tým, že by sme si v každom uzle pamätali buď jeho
hodnotu, alebo operátor, pričom typ uzla by sme rozlišovali podľa toho,
či sú smerníky na oboch synov rovné `NULL`.

### Operátory

Okrem operátorov, ktoré sme používali, existuje niekoľko ďalších, ako
napríklad nasledujúce:

  - *Bitové operátory* pracujú s celým číslom ako s poľom bitov
    (vhodnejšie sú `unsigned` typy):
      - `<<` a `>>` posúvajú bity doľava a doprava, zodpovedajú
        násobeniu a deleniu mocninami dvojky.
      - `&` (*and* po bitoch), | (*or* po bitoch), ^ (*xor* po bitoch),
        \~ (negácia po bitoch).
  - *Ternárny operátor* `(podmienka)?(hodnota pre true):(hodnota pre
    false)`
      - `cout << x << " je " << ((x%2==0) ? "parne" : "neparne") <<
        endl;`
  - Pozor na rozdiel medzi `a[i++]=0` a `a[++i]=0`, prehľadnejšie je
    použiť dva príkazy: `a[i]=0; i++;` alebo `i++; a[i] = 0;`

### Cyklus `do-while`

Cyklus `do-while` je obdobou cyklu `while` s vyhodnocovaním podmienky na
konci iterácie. Nasledujúce dva spôsoby písania cyklu sú viac-menej
ekvivalentné:

```cpp
do { 
    prikazy;
} while(podmienka);

while (true) {
    prikazy;
    if (!podmienka) break;
}
```

### Makrá a konštanty

Konštantu možno zadefinovať napríklad aj takto:

```cpp
#define MAXN 100
```

Na rozdiel od konštanty s definíciou

```cpp
const int maxN = 100;
```

sa pri použití `#define` konštantná premenná `MAXN` reálne nevytvára
(nevyhradzuje sa pre ňu pamäťové miesto); všetky výskyty `MAXN` sú
preprocesorom kompilátora nahradené v zdrojovom kóde konštantou `100`.

Okrem konštánt možno definovať aj zložitejšie makrá s parametrami:

```cpp
/* Definicia makra: */
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

/* Priklad pouzitia: */
cout << MIN(a*a, b+5);

/* Preprocesor vykona substituciu za MIN, ktorou dostane: */
cout << ((a*a) < (b+5) ? (a*a) : (b+5));
```

  - Bez dostatočného množstva zátvoriek by pri použití makra `MIN` mohlo
    dôjsť k „interakcii s okolím”.
  - Vo všeobecnosti je odporúčané vyvarovať sa použitia makier.

### Delenie programu na súbory

  - Väčší program chceme rozdeliť na viac súborov
  - Chceme vytvárať a používať vlastné knižnice - skupiny funkcií s
    podobným účelom
      - Napríklad knižnica implementujúca funkcie pracujúce so
        zásobníkom
  - Knižnicu rozdelíme na dva súbory, napr. `stack.h` a `stack.c` resp.
    `stack.cpp`

V hlavičkovom súbore (header file) `stack.h` zadeklarujeme funkcie, ale
neuvádzame ich kód, napr.:

```cpp
typedef int dataType;
struct stack {
    int top;  /* pozicia vrchného prvku zásobníka */
    dataType *items; /* pole prvkov */
};
void init(stack &s);
bool isEmpty(stack &s);
void push(stack &s, dataType data); 
dataType pop(stack &q);
```

Programy, ktoré chcú použiť stack, použijú `#include "stack.h"`

  - Všimnite si, že za `include` dávame meno štandardných knižníc v
    `<>`, našich vlastných v `""`

V súbore `stack.cpp` uvedieme kód funkcií, napr.

```cpp
#include "stack.h"
const int maxN = 100;
void init(stack &s) {
    s.top = -1;
    s.items = new dataType[maxN];
}
...
```

Pri kompilácii potom potrebujeme kompilátoru zadať mená všetkých častí
programu s príponou cpp resp. c, napríklad

    g++ -o program main.cpp stack.cpp

  - Práve jeden z kompilovaných zdrojových súborov musí obsahovať
    funkciu `main`.

### Zopár užitočných funkcií

**Alokácia pamäte**

  - V jazyku C nie sú definované operátory `new` a `delete`, resp.
    `new[]` a `delete[]`.
  - Pamäť sa alokuje funkciou `malloc`, ktorá alokuje kus pamäte s daným
    počtom bajtov.
      - V prípade neúspechu vráti `NULL`.
      - V prípade úspechu vráti smerník na `void`, ktorý je následne
        nutné pretypovať.
  - Uvoľnenie pamäte realizuje funkcia `free`.
  - Pri výpočte veľkosti potrebnej pamäte sa zvyčajne používa operátor
    `sizeof`.

<!-- end list -->

```cpp
#include <cstdlib>   // resp. #include <stdlib.h> v C

/* vytvorime pole 100 int-ov */
int *a = (int *)malloc(sizeof(int) * 100);
/* odalokujeme pole a */
free(a);
```

**Triedenie**

  - Funkcia `qsort` z knižnice `stdlib.h`.
  - Dostane pole, počet jeho prvkov, veľkosť každého prvku a funkciu,
    ktorá porovná dva prvky.
      - Funkciu teda posielame ako parameter.
      - Táto porovnávacia funkcia dostane dva smerníky typu `void *` (na
        dva prvky poľa).
      - Vráti záporné číslo, ak prvý prvok je menší, nulu, ak sú rovnaké
        a kladné číslo, ak je prvý väčší.
  - Ak si napíšeme porovnávaciu funkciu, môžeme triediť prvky hocijakého
    typu.

<!-- end list -->

```cpp
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}
int a[] = {5, 3, 2, 4, 1};
qsort(a, 5, sizeof(int), compare);
```

  - Existuje napríklad aj funkcia `bsearch` na binárne vyhľadávanie v
    utriedenom poli.

### Odbočka: argumenty typu const

  - V príklade vyššie máme funkciu s hlavičkou `int compare(const void
    *a, const void *b)`.
  - Argumentom typu `const void *a` programátor „sľubuje”, že nebude
    meniť obsah pamäte, na ktorú ukazuje smerník `a`.
  - Napríklad pre funkciu `void f(const int *a) {*a = 5;}` teda
    kompilátor vyhlási chybu.
  - Ak by sme naopak pri triedení chceli použiť funkciu s hlavičkou `int
    compare(void *a, void *b)`, kompilátor tiež vyhlási chybu, lebo
    `qsort` očakáva `const void *` a nie `void *`.
  - Za dobrú prax sa považuje používanie `const` na všetky parametre
    typu smerník alebo referencia, ktoré funkcia nepotrebuje meniť.

## Nepreberané črty jazyka C++

### Generické funkcie

Občas sa zíde napísať algoritmus, ktorý by mohol pracovať na dátach
rôznych typov. Napríklad triediť môžeme celé alebo desatinné čísla,
reťazce, zložitejšie štruktúry s určitým kľúčom a pod.

V C++ sa dajú písať takzvané *generické funkcie*, ktoré možno
„parametrizovať” podľa typu:

```cpp
#include <iostream>
using namespace std;

template <typename T>
T myMax (T a, T b) {
  return (a > b) ? a : b;
}

int main() {
    int i = 3;
    int j = 5;
    int k = myMax(i, j);
    cout << k << endl;
}
```

  - O generických funkciách sa budete viac učiť budúci semester.

### Preťaženie operátorov

Pre novovytvorené typy je možné štadardným operátorom jazyka C++
priradiť význam pomocou tzv. *preťaženia*. Napríklad v nasledujúcom
príklade definujeme operátor `<` na menách, ktorý najprv porovnáva
podľa priezviska a následne podľa krstného mena.

```cpp
struct meno {
    char *krstne, *priezvisko;
};

bool operator < (const meno &x, const meno &y) {
    return strcmp(x.priezvisko, y.priezvisko) < 0
            || strcmp(x.priezvisko, y.priezvisko) == 0
            && strcmp(x.krstne, y.krstne) < 0;
}
```

  - Podobne môžeme zadefinovať napríklad operátory `+` a `*` pre
    štruktúry reprezentujúce napríklad polynómy alebo komplexné čísla.
  - `cout << "Hello"` používa preťažený operátor `<<` pre výstupný prúd
    na ľavej strane a reťazec na pravej strane.

### Reťazce typu `string`

  - V C++ je možné okrem klasických C-čkových reťazcov použiť aj typ
    `string` z C++.
  - Jeho použitie je pohodlnejšie, sám si určuje potrebnú veľkosť
    pamäte.
  - Reťazce tohto typu sú objekty, do funkcií ich odovzdávame väčšinou
    referenciou (cez &).
  - K jednotlivým znakom pristupujeme pomocou `[]` (ako u polí) alebo
    pomocou metódy `at`.

<!-- end list -->

```cpp
#include <string>
#include <iostream>
using namespace std;

int main() {
    char cstr[100] = "Ahoj\n";
    string str = "Ako sa mas?\n";
    string str2;

    /* Do str mozno pomocou operatora = 
     * korektne priradit konstantne retazce,
     * C-ckove retazce (polia znakov), 
     * aj ine premenne typu string. */
    str2 = "Ahoj\n";
    str2 = cstr;
    str2 = str;

    /* Meranie dlzky retazca: */
    cout << "Dlzka je: " << str.length() << endl;

    /* Pomocou operatora + mozeme spojit dva retazce do jedneho. */
    str2 = cstr + str;
    cout << str2 << endl;

    /* Funguje porovnanie pomocou ==, !=, <, ...
     * (bud dvoch C++ stringov, alebo C++ stringu a C stringu) */
    if (str < str2) {
        cout << "Prvy je mensi" << endl;
    } else if (str == str2) {
        cout << "Rovnaju sa" << endl;
    } else {
        cout << "Druhy je mensi" << endl;
    }
}
```

  - Pomocou metódy `c_str()` možno získať z reťazca typu `string`
    hodnotu typu `const char*`.

### Dátová štruktúra `vector`

  - Súčasťou štandardnej knižnice jazyka C++ je viacero rôznych
    [dátových štruktúr](http://www.cplusplus.com/reference/stl/).
  - Ide o generické štruktúry, ktoré môžu uchovávať dáta rôznych typov.
      - elegantnejšie ako naše riešenie s `dataType`
      - v jednom programe môžeme mať štruktúry uchovávajúce rôzne typy

Spomenieme dátovú štruktúru `vector`
[1](http://www.cplusplus.com/reference/vector/vector/):

  - Elegantnejšia verzia dynamických polí z prednášky.

Vytvorenie nového vektora

```cpp
// vytvori pole celych cisel s nula cislami
vector<int> a;       
// vytvori pole 5 celych cisel, ktore nastavi na 1
vector<int> a(5,1);  
```

Prístup k prvkom vektora:

  - Pomocou `a[index]` podobne ako pri poliach, nekontroluje, či je
    index v medziach poľa.
  - Funkciou `a.at(index)`, ktorá v prípade indexu mimo rozsahu vyhodí
    výnimku (program spadne) a nenarobí chaos v pamäti, ľahšie sa hľadá
    chyba.
  - V obidvoch prípadoch môžeme aj priraďovať: `a[index] = value;
    a.at(index) = value;`

<!-- end list -->

  - Ďalšie metódy na prácu s vektormi:
      - `a.push_back(x)` vloží hodnotu `x` ako nový prvok na koniec
        poľa, podľa potreby pritom pole realokuje a pod.
      - `a.size()` vráti počet prvkov v poli.

<!-- end list -->

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> a;
    
    while(true) {  
        // nacitame postupnost nezapornych cisel 
        // ukoncenu -1, ulozime do vektora
        int prvok;
        cin >> prvok;
        if (prvok < 0) {
            break;
        }
        a.push_back(prvok);
    }
    // vypiseme prvky vektora
    for (int i = 0; i < (int)a.size(); i++) {
        cout << a[i] << endl;  // alebo a.at(i)
    }
}
```

Algoritmus na **triedenie**:

  - V knižnici <algorithm>

<!-- end list -->

```cpp
//triedime normalne pole
int A[6] = {1, 4, 2, 8, 5, 7};
sort(A, A + 6);

//triedime vektor
vector <int> A;
sort(A.begin(), A.end());

//triedime podla nasej porovnavacej funkcie, napr. podla absolutnej hodnoty
struct cmp {
    bool operator()(int x, int y) { return abs(x) < abs(y); }
};
cmp c;
sort(A.begin(), A.end(), c);
```

2D matica pomocou vektora:

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    // nacitanie a vypis matice m x n
    int m, n;
    cin >> m >> n;

    vector<vector<int>> a(m, vector<int> (n, 0));

    for (int i = 0; i < (int)a.size(); i++) {
        for (int j = 0; j < (int)a[i].size(); j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 0; i < (int)a.size(); i++) {
        for (int j = 0; j < (int)a[i].size(); j++) {
            cout << " " << a[i][j];
        }
        cout << endl;
    }
}
```

### Range-based for loop

  - Špeciálny cyklus cez prvky vektora a pod.
      - nepotrebujeme zavádzať premennú pre index
      - podobný cyklus uvidíte podrobnejšie v Jave

<!-- end list -->

```cpp
#include <iostream>
#include <vector>
using namespace std; 

void vypis(const vector<int> &a) {
  // vypise vsetky prvky vektora a
  for (const int &value : a) { 
    cout << value << ' ';
  }
  cout << '\n';  
}

int main() {
  vector<int> a;

  // do vektora a vlozi prvky 0,..,5
  for(int value : {0,1,2,3,4,5}) {
      a.push_back(value);
  }

  vypis(a);  // vypise 0 1 2 3 4 5
 
  // zvysi kazdy prvok vektora o 1
  for (int &value : a) { 
      value++;
  }

  vypis(a); // vypise 1 2 3 4 5 6
}
```

### Slovník, map

Štruktúra **map** implementuje slovník, pričom zadáme dva typy: kľúč a
hodnota

  - väčšinou je implementovaný pomocou nejakej verzie binárnych
    vyhľadávacích stromov
  - existuje aj unordered\_map, ktorý využíva hašovanie

<!-- end list -->

```cpp
  map <string, string> zoznam;
  zoznam["Jozko Mrkvicka"] = "02/12345678";
  zoznam["Janko Hrasko"] = "02/87654321";
  if (zoznam.count("Jozko Mrkvicka") > 0) {
      cout << zoznam["Jozko Mrkvicka"] << endl;
  }
  // prejdenie vsetkych zaznamov v slovniku pomocou iteratora
  cout << "Vsetky zaznamy:" << endl;
  for(map <string, string>::iterator i = zoznam.begin();
      i != zoznam.end(); i++) {
      // i->first je meno, i->second je cislo
      cout << i->first << " " << i->second << endl;
  }
```

### Stream

  - Textové súbory môžeme načítavať alebo zapisovať podobne ako sme
    pracovali s konzolou cez `cin` a `cout`
  - Budeme využívať typy a funkcie zadefinované v knižnici `fstream`.
  - `ifstream` je typ súboru určený na čítanie, `ofstream` na zápis

<!-- end list -->

```cpp
#include <fstream>
#include <iomanip>
using namespace std;

int main () {
    // otvorenie súboru
    ofstream fw;
    fw.open ("test.txt");     
    // do fw zapisujeme podobne ako na cout
    fw << "10*32=" << 10*32 << endl; 
    // vypise 0.666667
    fw << 2.0/3.0 << endl; 
    // vypise 0.67
    fw << setprecision(2) << 2.0/3.0 << endl;
    // vypise 6.67e-01
    fw << scientific << 2.0/3.0 << endl; 
    fw.close();
}
```

  - Knižnica `iomanip` umožňuje formátovanie výstupu napríklad pomocou
    manipulátorov `setprecision()`, `setfill()`, `setw()`, `scientific`
    atď

Podobne môžeme otvoriť aj súbor, z ktorého budeme čítať vstup. V
príklade načítame pole celých čísel.

```cpp
#include <fstream>
#include <iostream>
using namespace std;
const int MAX = 100;

int main () {
    ifstream fr;
    fr.open ("vstup.txt");

    int pocet, a[MAX];
    fr >> pocet;
    for (int i = 0; i < pocet; i++) {
        fr >> a[i];
    }
    fr.close();

    for (int i = 0; i < pocet; i++) {
      cout << a[i] << endl;
    }
}
```

Kontrola správneho otvorenia súboru a iné chyby

  - Funkcia `f.fail()` vráti `true`, ak vznikla chyba (väčšinou pri
    otvorení neexistujúceho súboru)
  - Druhou možnosťou je testovať správne otvorenie pomocou testovania
    premennej typu `ofstream` alebo `ifstream`.
      - Technicky ide o preťaženie operátora konverzie na `bool` resp.
        na `void*`, robí negáciu funkcie `fail`

<!-- end list -->

```cpp
  ifstream fr1("vstup1.txt");
  if(fr1.fail()) {
    cout << "Cannot open vstup1.txt file.\n";
    return 1;
  }

  ifstream fr2("vstup2.txt"); 
  if(!fr2) {
    cout << "Cannot open vstup2.txt file.\n";
    return 1;
  }
  // tiez mozeme pouzit assert(fr2)
```

Testovanie konca súboru môžeme robiť pomocou funkcie `eof`

```cpp
ifstream fin("vstup.txt");
while(!fin.eof()) {
    char c;
    fin >> c;
    cout << c;
}
```

Podobne ako pri konzole môžeme použiť funkciu `getline`, ktorá načíta
celý riadok. Nasledovný príklad spočíta v jednotlivých riadkoch počet
bodiek.

```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main(void){
    ifstream f("vstup.txt");;
    string line;
    while (getline(f,line)){
        int pocet = 0;
        for (int i = 0; i < line.length(); i++){
            if (line[i] == '.') {
                pocet++;
            }
        }
        cout << pocet <<endl;
    }
}
```

