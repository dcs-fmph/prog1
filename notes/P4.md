---
title: Prednáška 4
---

* TOC
{:toc}

## Oznamy

Čo nás čaká v najbližších dňoch

  - Dnes budú doplnkové cvičenia.
      - Sú odporúčané hlavne pre tých, ktorí v utorok na cvičeniach
        nevyriešia aspoň dva príklady.
      - Bude možné získať jeden bod za bonusovú rozcvičku.
  - V pondelok 6.10. bude časť prednášky teoretické cvičenie, na ktorom
    bude krátky test.
      - Test bude z prvých troch prednášok.
      - Ak máte aspoň jedny cvičenia uznané z testu pre pokročilých, na
        test nemusíte ísť.
      - Na teste bude povolené používať pero a ťahák vo forme jedného
        obojstranne popísaného listu A4.

## Funkcie

*Funkcia* je samostatný kus kódu (postupnosť príkazov) s určitým menom.
Po zavolaní funkcie jej menom sa daná postupnosť príkazov vykoná.

  - V iných programovacích jazykoch sa používajú aj podobné termíny ako
    *procedúra*, *metóda*, či *podprogram*.
  - Funkcia vo všeobecnosti dostane niekoľko (aj nula) vstupných
    argumentov, ktoré môže pri svojom behu používať.
  - Funkcia tiež môže vrátiť výstupnú hodnotu.
  - Ide teda o veľmi podobný koncept ako funkcie v matematike (ako
    napríklad sin(*x*)):
      - Oboje si možno predstaviť ako „krabičku”, ktorá na základe
        niekoľkých vstupných hodnôt vráti nejakú výstupnú hodnotu.
      - Funkcie v C/C++ ale môžu okrem vracania výstupných hodnôt
        vykonávať ľubovoľný kód, teda napríklad aj niečo vypisovať na
        konzolu a podobne.

### Obvod trojuholníka bez použitia funkcií

Užitočnosť funkcií ilustrujeme na príklade. Chceme napísať program,
ktorý od používateľa načíta súradnice vrcholov trojuholníka *ABC* a na
výstup vypíše obvod tohto trojuholníka. Beh takéhoto programu teda môže
vyzerať napríklad takto:

    Zadaj suradnice vrcholu A: 0 0
    Zadaj suradnice vrcholu B: 3 0
    Zadaj suradnice vrcholu C: 0 4
    Obvod trojuholnika ABC: 12

Obvod spočítame ako súčet dĺžok jednotlivých strán, v programe teda
trikrát opakujeme výpočet dĺžky strany:

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double Ax, Ay, Bx, By, Cx, Cy;
    
    cout << "Zadaj suradnice vrcholu A: "; 
    cin >> Ax >> Ay;
    cout << "Zadaj suradnice vrcholu B: ";
    cin >> Bx >> By;
    cout << "Zadaj suradnice vrcholu C: ";
    cin >> Cx >> Cy;
    
    /* Spocitaj dlzky jednotlivych stran: */
    double a = sqrt((Bx - Cx) * (Bx - Cx) 
                    + (By - Cy) * (By - Cy));
    double b = sqrt((Ax - Cx) * (Ax - Cx) 
                    + (Ay - Cy) * (Ay - Cy));
    double c = sqrt((Ax - Bx) * (Ax - Bx) 
                    + (Ay - By) * (Ay - By));
    
    cout << "Obvod trojuholnika ABC: " << a + b + c;
}
```

Opakované písanie toho istého vzorca na výpočet dĺžky strany je prácne;
navyše pri ňom ľahko spravíme chybu. V nasledujúcom programe ho teda
nahradíme funkciou.

### Obvod trojuholníka s použitím funkcie

Videli sme teda, že na výpočet obvodu trojuholníka sa nám môže zísť
funkcia počítajúca vzdialenosť medzi dvoma bodmi v rovine, t.j. dĺžku
úsečky. Tá môže v C/C++ vyzerať napríklad takto:

```cpp
double dlzka(double x1, double y1, double x2, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
```

Týmto sme zadefinovali funkciu s názvom `dlzka` so štyrmi *vstupnými
argumentmi* `x1, y1, x2, y2` typu `double`, reprezentujúcimi súradnice
dvojice bodov v rovine. Pred samotný názov funkcie sme zadali *návratový
typ* funkcie, ktorým je `double` – táto funkcia teda bude vracať na
výstupe reálne čísla. Nakoniec sme zadefinovali samotné telo funkcie,
tentokrát pozostávajúce z jediného špeciálneho príkazu `return`, ktorým
funkcia vracia svoju výstupnú hodnotu.

Kompletný program na výpočet obvodu trojuholníka môže s použitím funkcie
`dlzka` vyzerať napríklad takto:

```cpp
#include <iostream>
#include <cmath>
using namespace std;

/* Definicia funkcie dlzka: */
double dlzka(double x1, double y1, double x2, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int main() {
    double Ax, Ay, Bx, By, Cx, Cy;
    
    cout << "Zadaj suradnice vrcholu A: "; 
    cin >> Ax >> Ay;
    cout << "Zadaj suradnice vrcholu B: ";
    cin >> Bx >> By;
    cout << "Zadaj suradnice vrcholu C: ";
    cin >> Cx >> Cy;
    
    // Spocitaj dlzky jednotlivych stran:

    // Volanie funkcie dlzka s argumentmi Bx, By, Cx, Cy
    double a = dlzka(Bx, By, Cx, Cy);
    // Volanie funkcie dlzka s argumentmi Ax, Ay, Cx, Cy
    double b = dlzka(Ax, Ay, Cx, Cy);
    // Volanie funkcie dlzky s argumentmi Ax, Ay, Bx, By
    double c = dlzka(Ax, Ay, Bx, By);
    
    cout << "Obvod trojuholnika ABC: " << a + b + c;
}
```

Telo funkcie nemusí pozostávať iba z jediného príkazu. Napríklad ešte
jednoduchšie by sme funkciu `dlzka` mohli napísať takto:

```cpp
double dlzka(double x1, double y1, 
            double x2, double y2) {
    double dx = x1 - x2;
    double dy = y1 - y2; 
    return sqrt(dx * dx + dy * dy);
}
```

Cvičenie:

  - V Pascale existuje funkcia `sqr`, ktorá na vstupe berie reálne číslo
    `x` a výstupom je toto číslo umocnené na druhú. Naprogramujte túto
    funkciu v C/C++ a použite ju na zjednodušenie funkcie `dlzka`.
  - Mohli by sme použiť aj `pow(x,2)` (treba ` #include  `<cmath>), ale
    môže byť jednoduchšie zrátať `x*x`.

## Výhody funkcií

Funkcie sú užitočné z viacerých dôvodov:

  - Umožňujú vytvoriť „skratku” pre často používané časti kódu, ktoré
    tak nie je nutné zakaždým písať nanovo.
  - Umožňujú používanie kusov kódu vytvorených iným programátorom.
    Napríklad sme použili funkciu `sqrt`, ktorá vráti druhú odmocninu
    svojho vstupu.
  - Funkcie umožňujú rozdeliť písanie programu na menšie časti. Zvlášť
    sa môžeme sústrediť na telo programu, ktoré používa funkciu a zvlášť
    na implementáciu samotnej funkcie. Tieto dve časti môžu robiť aj
    rôzni programátori.

## Definícia funkcie

Definícia funkcie pozostáva z nasledujúcich častí:

  - **Typ návratovej hodnoty funkcie.** Funkcia z úvodného príkladu
    napríklad vracia vzdialenosť bodov v rovine, teda hodnotu typu
    `double`. Podobne môžeme písať funkcie vracajúce iné návratové typy,
    napríklad `int`. Funkcie, ktoré nemajú vracať žiadnu hodnotu majú
    špeciálny návratový typ `void` – ide typicky o funkcie, ktoré len
    vykonajú určitú činnosť, napríklad vypísanie textu na konzolu a
    podobne.
  - **Identifikátor funkcie.** Funkciu môžeme (v rámci určitých medzí)
    pomenovať prakticky ľubovoľne, rovnako ako pri premenných. Vhodné je
    však použiť názov, ktorý vystihuje úlohu danej funkcie (napríklad
    `dlzka`).
  - **Zoznam vstupných parametrov funkcie.** V zátvorkách za názvom
    funkcie je zoznam typov a identifikátorov vstupných argumentov,
    ktoré funkcia očakáva. V úvodnom príklade funkcia očakáva súradnice
    dvoch bodov v rovine, teda štyri hodnoty typu `double`. Ak funkcia
    neočakáva žiaden vstupný argument, môžeme do zátvoriek napísať
    `void` alebo nechať zoznam argumentov prázdny.
  - **Telo funkcie.** Do zložených zátvoriek za definíciou funkcie
    píšeme postupnosť príkazov, ktoré má funkcia vykonať.
  - **Príkaz `return`.** Vracia návratovú hodnotu funkcie.

<!-- end list -->

```cpp
typ_navratovej_hodnoty identifikator_funkcie(zoznam_vstupnych_argumentov) {
    telo_funkcie // Môže obsahovať príkazy return.
}
```

## Ďalšie príklady funkcií

### Súčet čísel od *a* po *b*

Ukážeme si tri verzie funkcie, ktorá dostane dvojicu celých čísel *a*,
*b* a spočíta súčet všetkých celých čísel od *a* po *b* vrátane.

  - Prvá verzia tento súčet vráti ako návratovú hodnotu.
  - Druhá verzia súčet vypíše, vrátane sčitovaných čísel, jej návratový
    typ bude `void`.
  - Tretia verzia súčet aj vypíše aj vráti.

<!-- end list -->

```cpp
/* Funkcia, ktora vrati sucet a + (a+1) + ... + (b-1) + b */
int sum(int a, int b) {
    int result = 0;
    for (int i = a; i <= b; i++) {
        result += i;
    }    
    return result;
}

/* Funkcia, ktora vypise cisla a, (a+1), ..., b  a ich sucet */
void printNumbers(int a, int b) {
    int result = 0;
    for (int i = a; i <= b; i++) {
        if (i > a) {
            cout << " + ";
        }
        cout << i;
        result += i;
    }    
    cout << " = " << result << endl;
}

/* Funkcia, ktora vypise cisla a, (a+1), ..., b  a ich sucet
 * a tento sucet aj vrati. */
int sumAndPrint(int a, int b) {
    int result = 0;
    for (int i = a; i <= b; i++) {
        if (i > a) {
            cout << " + ";
        }
        cout << i;
        result += i;
    }    
    cout << " = " << result << endl;
    return result;
}
```

Program využívajúci tieto funkcie môže vyzerať napríklad takto:

```cpp
#include <iostream>
using namespace std;

// sem pridu definicie funkcii sum, printNUmbers, sumAndPrint 
// uvedene vyssie

int main() {
    int a, b;
    
    cout << "Zadaj dvojicu celych cisel: ";
    cin >> a >> b;

    cout << "Test funkcie sum" << endl;
    cout << "Sucet celych cisel od " << a << " po " << b << ": ";
    // zavolame funkciu a vysledok priamo vypiseme
    cout << sum(a, b) << endl;
    // vysledok funkcie mozeme ulozit do premennej 
    // a pouzit neskor:
    int sucet = sum(a, b); 
    cout << "Druha mocnina suctu cisel je: " << sucet * sucet << endl;

    cout << endl << "Test funkcie printNumbers" << endl;
    // tato funkcia nema vysledok, nic neukladame
    printNumbers(a, b);
    
    cout << endl << "Test funkcie sumAndPrint" << endl;
    // dalsia funkcia vypise aj vrati hodnotu
    int sucet2 = sumAndPrint(a, b);
    cout << "Druha mocnina suctu cisel je: " << sucet2 * sucet2 << endl;
    
    // vystupnu hodnotu funkcie mozeme aj odignorovat
    sumAndPrint(a,b); 
}
```

## Príkaz `return`

Pozrime sa teraz bližšie na špeciálny príkaz `return`:

  - Po vykonaní príkazu `return` je funkcia okamžite zastavená a jej
    výstupná hodnota je výraz za slovom `return`.
  - Funkcia môže obsahovať aj viacero volaní `return`. Akonáhle sa však
    jedno z nich vykoná, funkcia končí s danou návratovou hodnotou.
    Napríklad:

<!-- end list -->

```cpp
#include <iostream>
using namespace std;

int f(void) {
    return 1;
    return 2; // Nikdy sa nevykona.
    return 3; // Nikdy sa nevykona.
}

int main() {
    cout << f() << endl; // Vypise 1.
}
```

  - Funkcia s návratovým typom `void` môže tiež obsahovať príkaz
    `return`, avšak bez návratovej hodnoty.
      - V takom prípade `return` slúži iba na ukončenie vykonávania
        funkcie, väčšinou je lepšie prepísať inak
      - Tu je ukážka, kde namiesto `return` by bolo lepšie použiť
        `else`:

<!-- end list -->

```cpp
#include <iostream>
using namespace std;

void akeCislo(int n) {
    if (n >= 0) {
        cout << "Cislo je nezaporne." << endl;
        return;
    }

    // Vykona sa len v pripade n < 0:
    cout << "Cislo je zaporne." << endl; 
}

int main() {
    int n;
    cin >> n;
    akeCislo(n);
}
```

  - Napríklad minimum z dvoch čísel môžeme vypočítať dvoma rôznymi
    spôsobmi:

<!-- end list -->

```cpp
int minimum1(int a, int b) {
    int minval;
    if (a < b) {
        minval = a;
    } else {
        minval = b;
    }
    return minval;
}

int minimum2(int a, int b) {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}
```

  - Funkcie s návratovým typom iným ako `void` je žiadúce písať tak, aby
    na ľubovoľnom vstupe ich vykonávanie vždy skončilo príkazom
    `return`.
      - Ak totiž takáto funkcia skončí inak, než príkazom `return`, jej
        výstupná hodnota je nedefinovaná (použije sa „hocijaký
        nezmysel”), čo môže viesť k zákerným chybám.

Cvičenie: Nájdite hodnotu nasledujúcej funkcie pre *n=6* a *n=7*. Viete
stručne popísať, čo funkcia robí pre všeobecné *n*?

```cpp
int zahada(int n) {
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return i; 
        }
    }
    return n;
}
```

## Lokálne a globálne premenné

Premenné v C/C++ možno rozdeliť na *globálne* a *lokálne*:

  - *Globálne premenné* možno používať vo všetkých funkciách, ktoré sú v
    programe definované za touto premennou.
  - *Lokálne premenné* sú definované vo vnútri funkcie a môžu sa
    používať iba v rámci nej (alebo iba v rámci niektorej časti
    funkcie, ak je premenná definovaná napríklad v tele cyklu a
    podobne).

Platí navyše, že:

  - Viaceré funkcie môžu mať lokálne premenné s tým istým názvom – každá
    funkcia potom používa tú svoju. Toto sa bežne používa.
  - Ak má lokálna premenná rovnaký názov ako nejaká globálna premenná,
    lokálna premenná *prekryje* globálnu – funkcia teda používa svoju
    lokálnu premennú (bližšia košeľa ako kabát). Toto radšej nerobte,
    môže vzniknúť chaos.

Je silno odporúčané *používať predovšetkým lokálne premenné*. Väčšie
programy s globálnymi premennými môžu byť veľmi neprehľadné.

Nasledujúci program obsahuje globálnu premennú `x` a v každej funkcii
lokálnu premennú s názvom `y`:

```cpp
#include <iostream>
using namespace std;

int x;

void f(void) {
    int y = 10;
    cout << x << " " << y << endl;      
}

int main() {
    x = 10;
    int y = 20;
        
    f();                            // Vypise 10 10.  
    cout << x << " " << y << endl;  // Vypise 10 20.
}
```

## Parametre funkcií

### Odovzdávanie parametrov hodnotou

Vstupné parametre funkcií sa správajú ako lokálne premenné danej
funkcie. Pri volaní funkcie sa každému parametru priradí určitá hodnota.
Uvažujme napríklad funkciu

```cpp
void f(int a, int b) {
    // ...
}
```

Pri volaní

```cpp
f(1,2);
```

sa parametru `a` priradí hodnota 1 a parametru `b` sa priradí hodnota 2.
Tieto sa ďalej správajú ako lokálne premenné funkcie `f`. Možno ich teda
meniť, ale táto zmena sa neprejaví na mieste, odkiaľ funkciu voláme.
Tento mechanizmus nazývame *odovzdávaním parametrov hodnotou*.

Príklad:

```cpp
#include <iostream>
using namespace std;

void f(int n) {
    n++;
    cout << n << endl;
}

int main() {
    int n = 1;
    f(n);               // Vypise 2
    cout << n << endl;  // Vypise 1
}
```

### Odovzdávanie parametrov referenciou

V prípade, že pred názov niektorého parametra v hlavičke funkcie
napíšeme `&`, parameter sa bude *odovzdávať referenciou*.

  - Za takýto parameter možno pri volaní funkcie dosadiť iba premennú
    (kým pri odovzdávaní hodnotou môžeme použiť napríklad aj konštanty
    alebo iný výraz).
  - Namiesto hodnoty sa funkcii pošle adresa premennej v pamäti
    (referencia).
  - Funkcia potom bude túto premennú používať pod novým názvom; jej
    prípadné zmeny sa prejavia aj na mieste, odkiaľ bola funkcia
    volaná.

Príklad:

```cpp
#include <iostream>
using namespace std;

void f(int &n) {
    n++;
    cout << n << endl;
}

int main() {
    int n = 1;
    f(n);               // Vypise 2.
    cout << n << endl;  // Vypise 2.
}
```

Ďalej si ukážeme niekoľko použití odovzdávania parametrov referenciou.

### Viac ako jedna návratová hodnota

Odovzdávanie parametra referenciou používame napríklad vtedy, keď
potrebujeme vrátiť viac ako jednu výstupnú hodnotu.

Napríklad nasledujúca funkcia `stred` dostane súradnice dvoch bodov
`[x1,y1]` a `[x2,y2]` a do parametrov `[xm,ym]`, ktoré sú odovzdané
referenciou, uloží súradnice stredu úsečky spájajúcej body `[x1,y1]` a
`[x2,y2]`.

```cpp
#include <iostream>
using namespace std;

void stred(double x1, double y1, double x2, double y2, 
           double &xm, double &ym) {
    xm = (x1 + x2) / 2;
    ym = (y1 + y2) / 2;
}

int main() {
    double Ax, Ay, Bx, By;
    
    cout << "Zadaj suradnice bodu A: ";
    cin >> Ax >> Ay;
    cout << "Zadaj suradnice bodu B: ";
    cin >> Bx >> By;
    
    double Mx, My;
    stred(Ax, Ay, Bx, By, Mx, My);
    cout << "Stred usecky AB je [" 
         << Mx << ", " << My << "]." << endl; 
}
```

### Funkcia `swap`

Typickým príkladom použitia odovzdávania parametrov referenciou je
funkcia `swap`, ktorá vymení hodnoty dvoch premenných, ktoré dostane ako
parametre.

```cpp
#include <iostream>
using namespace std;

void swap(int &a, int &b) {
    int tmp = a;
    a = b;
    b = tmp;
}

int main() {
    int x, y;
    cin >> x >> y;
    
    swap(x, y);
    
    cout << "x = " << x << ", y = " << y << endl; 
}
```

Keby sme funkcii odovzdali parameter hodnotou – čiže by sme funkciu
`swap` definovali s hlavičkou `void swap(int a, int b);` – vo funkcii
`main` by sa premenné nevymenili.

## Ošetrovanie chybných vstupov

Občas môže nastať potreba, aby parametre funkcie spĺňali určité
podmienky. V takom prípade môže byť potrebné korektne sa vysporiadať aj
so vstupmi, ktoré tieto podmienky nespĺňajú. Ukážeme si teraz zopár
možných prístupov k tomuto problému.

### Funkcia neošetrujúca chybné vstupy

Uvažujme napríklad nasledujúcu funkciu, ktorá počíta súčet všetkých
deliteľov čísla `n`. Jej základným predpokladom je, že `n` je *kladné*
celé číslo.

```cpp
#include <iostream>
using namespace std;

int sumOfDivisors(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (n % i == 0) {
            sum += i;    
        }        
    }   
    return sum;  
}

int main() {
    int n;
    cout << "Zadaj kladne cele cislo: ";
    cin >> n;
        
    cout << "Sucet delitelov " << n << ": " 
         << sumOfDivisors(n) << "." << endl;
}
```

Ak však používateľ zadá na vstupe nejaké záporné číslo, funkcia vždy
vráti nulu, čo nie je úplne v súlade s očakávaním. Jednou možnosťou by
samozrejme bolo prerobiť funkciu tak, aby pracovala správne aj na
záporných vstupoch. Sú však aj situácie, keď podobné riešenie nie je
možné. Ukážeme si preto ďalšie spôsoby, ako sa s nekorektným vstupom
vysporiadať.

### Použitie funkcie `assert`

V prípade použitia nekorektného vstupu napríklad môžeme celý program
ihneď ukončiť. Pohodlný spôsob, ako to spraviť, je použitie funkcie
`assert` (treba ` #include  `<cassert>). Táto funkcia kontroluje
platnosť nejakej podmienky. Ak je táto podmienka splnená, program
normálne pokračuje; v opačnom prípade sa program zastaví s chybovou
hláškou. Argumentom funkcie `assert` môže byť ľubovoľná booleovská
hodnota.

```cpp
#include <iostream>
#include <cassert>
using namespace std;

int sumOfDivisors(int n) {
    assert(n > 0);
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (n % i == 0) {
            sum += i;    
        }        
    }   
    return sum;  
}

int main() {
    int n;
    cout << "Zadaj kladne cele cislo: ";
    cin >> n;
        
    cout << "Sucet delitelov " << n << ": " 
         << sumOfDivisors(n) << "." << endl;
}
```

### Úspech výpočtu ako výstupná hodnota

Často je ale neprípustné v prípade jediného volania funkcie s
nekorektnými vstupmi ukončiť celý program. Chceli by sme teda vrátiť
dve hodnoty: samotný súčet deliteľov a indikátor, či boli argumenty
zadané správne.

  - Napríklad súčet deliteľov môžeme ukladať do parametra odovzdávaného
    referenciou.
  - Výstupom funkcie bude booleovská hodnota, ktorá bude `true` práve
    vtedy, keď výpočet funkcie prebehol správne (t.j. keď boli zadané
    správne argumenty). Túto výstupnú hodnotu je potom možné použiť pri
    volaní funkcie ako známku toho, že hodnota v parametre predanom
    referenciou je zmysluplná.

<!-- end list -->

```cpp
#include <iostream>
using namespace std;

bool sumOfDivisors(int n, int &sum) {
    if (n <= 0) {
        return false;
    } else {
        sum = 0;
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                sum += i;    
            }        
        }   
        return true;
    }  
}

int main() {
    int n, sum;
    cout << "Zadaj kladne cele cislo: ";
    cin >> n;
    
    if (sumOfDivisors(n, sum)) { 
        cout << "Sucet delitelov " << n << ": " 
             << sum << "." << endl;
    } else {
        cout << "Zly vstup" << endl;
    }
}
```

## Programy s viacerými funkciami

V programe možno volať iba funkcie, ktoré už predtým boli niekde
definované.

Tento program typicky neskompiluje (vo vnútri `f1` ešte nepozná `f2`)

```cpp
void f1(void) {
    f2();
}

void f2(void) {
    cout << "Hello, World!" << endl;
}
```

Tento program je v poriadku:

```cpp
void f2(void) {
    cout << "Hello, World!" << endl;
}

void f1(void) {
    f2();
}
```

## Funkcia `main`

Špeciálnou funkciou je v C/C++ funkcia `main`.

  - V programe ju nemožno volať – jediné jej volanie je automatické
    (začína sa ním beh programu).
  - Výstupná hodnota funkcie `main` sa interpretuje ako „spôsob
    ukončenia” programu (napríklad 0 pre korektné ukončenie, iné
    hodnoty pre chyby).
      - Funkciu `main` môžeme teda ukončit napríklad príkazom
        `return 0`.
  - Funkcia `main` môže mať aj určité presne špecifikované parametre
    (viac o tom neskôr).

## Funkcie: zhrnutie

  - Funkcie nám umožňujú rozbiť väčší program na menšie logické časti a
    tým ho sprehľadniť. Tiež nám umožňujú vyhnúť sa opakovaniu podobných
    kusov kódu.
  - Hlavička funkcie obsahuje návratový typ (môže byť `void`), meno
    funkcie, typy a mená parametrov.
  - V tele funkcie sú samotné príkazy. Vypočítanú hodnotu vrátime
    príkazom `return`.
  - Lokálne premenné sú viditeľné len vo funkcii, ktorá ich definuje,
    globálne vo všetkých funkciách.
  - Parametre odovzdávané hodnotou sú lokálne premenné inicializované
    hodnotami, ktoré sa zadajú pri volaní funkcie.
  - Parametre odovzdávané referenciou (`&`) sú len novým menom pre inú
    premennú.

